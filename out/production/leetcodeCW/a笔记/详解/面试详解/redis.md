# 使用场景概述
String类用来存缓存，对应的有穿透击穿雪崩
String也可以用于保存token，jwt=token+redis。补充：jwt对比session去中心化可扩展无需存储token
List可以进行消息队列
zset延迟队列，排行榜
分布式锁可以用setnx，redisson

# 具体问题回答
1. 项目中哪些场景用了redis
> 缓存数据库查询结果，用了设置无效key
> 
## Redis线程模型
1. redis为什么块?
> 1. 基于内存
> 2. 特殊的数据结构，SDS，ziplist跳表
> 3. 单线程减少上下文切换
> 4. IO多路复用技术。解决多个IO监听时，一个IO阻塞其他IO的问题
2. 为什么采用单线程? 
> 将网络IO以及指令读写全部交由一个线程处理。
3. 为什么引入多线程?
> 提高网络IO读写性能。执行命令仍然是单线程顺序执行。
# 三大缓存问题
1. 缓存穿透：都不存在
> 方案一：设置无效key，查redis时key1 为null。缺点是消耗内存，可能发生redis和db不一致问题
> 方案二：布隆过滤器，缓存预热时，预热布隆过滤器。优点：内存占用少没有多余key。实现复杂。

2. 缓存击穿：key过期查不到
> 方案一：互斥锁，未命中或者过期就获取setnx锁，避免redis更新前大量读。优点可以保证强一致性，缺点有锁需要等待，同时获取互斥锁压力过大
> 方案二：逻辑过期。跟互斥锁的区别是，即使拿不到锁也可以返回过期的数据，无需等待。有一致性问题
> 如果数据过期，尝试获取锁，并修改。获取不到锁，则返回过期数据。
> 如果数据没有过期，命中缓存。所以缺点是数据不能保证绝对一致

3. 缓存雪崩
> 请求到达数据库，1. 大量key同时失效 2. redis服务宕机
> 方案一：给不同key的TTL添加随机值
> 方案二：redis集群，哨兵模式，集群模式
> 方案三：给缓存业务添加限流策略

4. 双写不一致
> 更新先写数据库，造成cache为旧。先写cache，造成db为旧
> 方案一：旁路缓存，要更新直接删cache
> 方案二: 获取互斥锁
---
## 持久化 AOF
- 执行原理：写完之后，执行aof缓存区写执行语句
1. aof的潜在风险？
> 两个风险只能解决一个：主线程执行两个任务，中途挂掉会丢失aof。AOF缓冲区刷盘太慢影响下一条命令
> 如果采取always，可能影响下一条命令。如果每秒就会丢失aof
2. 源码实现不同时间的刷盘策略？
> 控制fsync()函数的调用时机
3. AOF的重写机制？
> 由子线程完成，保留key最新的value，覆盖旧的AOF文件

## 持久化RDB
- 执行原理：固定时间备份整个redis表，把物理内存复制到磁盘
1. 执行快照时数据能被修改吗？
> copy-on-write, 所有数据为只读。如果要修改就得复制一份更改。极端情况会因为复制占用2倍内存。
2. RDB和AOF混合模式？
> 通过RDB来进行AOF重写
3. 大key的影响
> RDB写入耗时，copy-on-write耗时。
> 客户端阻塞，网络阻塞。内存分布不均
---

# 缓存策略
1. 旁路缓存：以数据库为主，写时直接删除cache。读不到就更新db，通过db更新cache
2. 读写穿透：以cache为主，读不到就通过cache更新db。
3. 异步缓存：不更新db，异步批量更新db

# 数据结构
1. SDS的三大特点：空间预分配减少内存再分配数。保障二进制安全。len获取字符传的长度为O（1）
2. ziplist三大件：entries的prevlength会造成连环扩容，encoding记录data类型分配大小，data存储
3. quicklist：在双向链表上挂ziplist