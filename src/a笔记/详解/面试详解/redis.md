# 使用场景概述
String类用来存缓存，对应的有穿透击穿雪崩
String也可以用于保存token，jwt=token+redis。补充：jwt对比session去中心化可扩展无需存储token
List可以进行消息队列
zset延迟队列，排行榜
分布式锁可以用setnx，redisson

# 具体问题回答
1. 项目中哪些场景用了redis
> 缓存数据库查询结果，用了设置无效key
> 

# 三大缓存问题
1. 缓存穿透：都不存在
> 方案一：设置无效key，查redis时key1 为null。缺点是消耗内存，可能发生redis和db不一致问题
> 方案二：布隆过滤器，缓存预热时，预热布隆过滤器。优点：内存占用少没有多余key。实现复杂。

2. 缓存击穿：key过期查不到
> 方案一：互斥锁，未命中或者过期就获取setnx锁，避免redis更新前大量读。优点可以保证强一致性，缺点有锁需要等待，同时获取互斥锁压力过大
> 方案二：逻辑过期。跟互斥锁的区别是，即使拿不到锁也可以返回过期的数据，无需等待。有一致性问题
> 如果数据过期，尝试获取锁，并修改。获取不到锁，则返回过期数据。
> 如果数据没有过期，命中缓存。所以缺点是数据不能保证绝对一致

3. 缓存雪崩
> 请求到达数据库，1. 大量key同时失效 2. redis服务宕机
> 方案一：给不同key的TTL添加随机值
> 方案二：redis集群，哨兵模式，集群模式
> 方案三：给缓存业务添加限流策略

4. 双写不一致
> 更新先写数据库，造成cache为旧。先写cache，造成db为旧
> 方案一：旁路缓存，要更新直接删cache
> 方案二: 获取互斥锁

# 持久化 AOF
1. aof的潜在风险？
> 两个风险只能解决一个：主线程执行两个任务，中途挂掉会丢失aof。AOF缓冲区刷盘太慢影响下一条命令
> 如果采取always，可能影响下一条命令。如果每秒就会丢失aof
2. 源码实现不同时间的刷盘策略？
> 控制fsync()函数的调用时机
3. AOF的重写机制？
> 


# 缓存策略
1. 旁路缓存：以数据库为主，写时直接删除cache。读不到就更新db，通过db更新cache
2. 读写穿透：以cache为主，读不到就通过cache更新db。
3. 异步缓存：不更新db，异步批量更新db

# 数据结构
1. SDS的三大特点：空间预分配减少内存再分配数。保障二进制安全。len获取字符传的长度为O（1）
2. ziplist三大件：entries的prevlength会造成连环扩容，encoding记录data类型分配大小，data存储
3. quicklist：在双向链表上挂ziplist